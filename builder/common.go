package builder

import (
	"embed"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"slices"
	"strings"

	"gopkg.in/yaml.v3"
)

// embed assets
//
//go:embed all:assets
var assets embed.FS

const BuilderStartTag = "tag-rt-api-builder-start"
const BuilderEndTag = "tag-rt-api-builder-end"
const BuilderDescription = "This file is generated by rt-builder, DO NOT EDIT."

var engineMap = map[string]string{
	"net/http": "net_http",
}

var languageTailMap = map[string]string{
	"golang":     "go",
	"typescript": "ts",
}

type IBuilder interface {
	BuildServer() error
	BuildClient() error
}

type BuildContext struct {
	rootConfig      GApiRootConfig
	buildConfig     GApiConfig
	output          GApiRootOutputConfig
	rootConfigPath  string
	buildConfigPath string
}

type GApiRootOutputConfig struct {
	Kind       string `json:"kind" required:"true"`
	Language   string `json:"language" required:"true"`
	Dir        string `json:"dir" required:"true"`
	GoModule   string `json:"goModule"`
	HttpEngine string `json:"httpEngine"`
}

type GApiRootConfig struct {
	Listen  string                 `json:"listen"`
	Outputs []GApiRootOutputConfig `json:"outputs"`
}

type GApiDefinitionAttributeConfig struct {
	Name        string `json:"name" required:"true"`
	Type        string `json:"type" required:"true"`
	Required    bool   `json:"required"`
	Description string `json:"description"`
}

type GApiDefinitionImportConfig struct {
	Package string `json:"package"`
	Name    string `json:"name"`
}

type GApiDefinitionConfig struct {
	Description string                          `json:"description"`
	Attributes  []GApiDefinitionAttributeConfig `json:"attributes"`
	Import      *GApiDefinitionImportConfig     `json:"import"`
}

type GApiActionParameterConfig struct {
	Name        string `json:"name" required:"true"`
	Type        string `json:"type" required:"true"`
	Required    bool   `json:"required"`
	Description string `json:"description"`
}

type GApiActionReturnConfig struct {
	Type        string `json:"type" required:"true"`
	Description string `json:"description"`
}

type GApiActionConfig struct {
	Description string                      `json:"description"`
	Method      string                      `json:"method" required:"true"`
	Parameters  []GApiActionParameterConfig `json:"parameters"`
	Returns     []GApiActionReturnConfig    `json:"returns"`
}

type GApiConfig struct {
	Version     string                          `json:"version" required:"true"`
	ApiPath     string                          `json:"apiPath" required:"true"`
	Package     string                          `json:"package" required:"true"`
	Description string                          `json:"description"`
	Definitions map[string]GApiDefinitionConfig `json:"definitions" required:"true"`
	Actions     map[string]GApiActionConfig     `json:"actions"`
}

func ParseProjectDir(filePath string, projectDir string) (string, error) {
	// Check for project directory placeholders in the filePath
	patterns := []string{
		"$projectdir",
		"$projectDir",
		"${ProjectDir}",
		"$ProjectDir",
		"$project",
		"$Project",
		"${projectDir}",
		"${projectdir}",
		"${Project}",
		"${project}",
	}

	result := filePath

	for _, pattern := range patterns {
		if strings.HasPrefix(filePath, pattern) {
			result = strings.Replace(result, pattern, projectDir, 1)
			break
		}
	}

	// If result is a relative path, convert it to an absolute path
	if !filepath.IsAbs(result) {
		if absPath, err := filepath.Abs(result); err != nil {
			return "", fmt.Errorf("failed to convert path to absolute path: %w", err)
		} else {
			result = absPath
		}
	}

	return result, nil
}

func UnmarshalConfig(filePath string, v any) error {
	if content, err := os.ReadFile(filePath); err != nil {
		return err
	} else {
		switch filepath.Ext(filePath) {
		case ".json":
			return json.Unmarshal(content, v)
		case ".yaml", ".yml":
			return yaml.Unmarshal(content, v)
		default:
			return fmt.Errorf("unsupported file extension: %s", filepath.Ext(filePath))
		}
	}
}

func LoadConfig(filePath string) (GApiConfig, error) {
	var config GApiConfig

	if err := UnmarshalConfig(filePath, &config); err != nil {
		return GApiConfig{}, fmt.Errorf("failed to parse config file: %w", err)
	}

	return config, nil
}

func LoadRootConfig() (GApiRootConfig, string, error) {
	configPath := ""

	if len(os.Args) > 1 {
		if fileInfo, err := os.Stat(os.Args[1]); err == nil && !fileInfo.IsDir() {
			configPath = os.Args[1]
		}
	}

	if configPath == "" {
		// 在当前目录下，依次寻找 .gapi.json .gapi.yaml .gapi.yml
		searchFiles := []string{"./.gapi.json", "./.gapi.yaml", "./.gapi.yml"}
		for _, file := range searchFiles {
			if fileInfo, err := os.Stat(file); err == nil && !fileInfo.IsDir() {
				configPath = file
				break
			}
		}
	}

	if !filepath.IsAbs(configPath) {
		if absPath, err := filepath.Abs(configPath); err != nil {
			return GApiRootConfig{}, "", fmt.Errorf("failed to convert config path to absolute path: %v", err)
		} else {
			configPath = absPath
		}
	}

	var config GApiRootConfig

	if err := UnmarshalConfig(configPath, &config); err != nil {
		return GApiRootConfig{}, "", fmt.Errorf("failed to parse config file: %w", err)
	}

	projectDir := filepath.Dir(configPath)

	for i, output := range config.Outputs {
		var err error
		config.Outputs[i].Dir, err = ParseProjectDir(output.Dir, projectDir)
		if err != nil {
			return GApiRootConfig{}, "", fmt.Errorf("failed to parse output dir: %w", err)
		}

		if !filepath.IsAbs(config.Outputs[i].Dir) {
			config.Outputs[i].Dir = filepath.Join(projectDir, config.Outputs[i].Dir)
		}
	}

	return config, configPath, nil
}

func Output() error {
	rootConfig, rootConfigPath, err := LoadRootConfig()
	if err != nil {
		log.Panicf("Failed to load config: %v", err)
	}

	versions := []string{"gapi", "gapi.v1"}
	projectDir := filepath.Dir(rootConfigPath)
	log.Printf("gapi: config file: %s\n", rootConfigPath)
	log.Printf("gapi: project dir: %s\n", projectDir)

	for _, output := range rootConfig.Outputs {
		if output.HttpEngine != "" {
			systemDir := filepath.Join(output.Dir, "__gapi_system__")
			assetsFile := fmt.Sprintf(
				"assets/%s/%s/%s/%s.%s",
				output.Language,
				output.Kind,
				"__gapi_system__",
				engineMap[output.HttpEngine],
				languageTailMap[output.Language],
			)

			if err := os.RemoveAll(systemDir); err != nil {
				log.Fatalf("failed to remove system dir: %v", err)
			} else if err := os.Mkdir(systemDir, 0755); err != nil {
				log.Fatalf("failed to create system dir: %v", err)
			} else if content, err := assets.ReadFile(assetsFile); err != nil {
				log.Fatalf("failed to read assets file: %v", err)
			} else if err := os.WriteFile(filepath.Join(systemDir, "http.go"), content, 0644); err != nil {
				log.Fatalf("failed to write assets file: %v", err)
			}
		}

		walkErr := filepath.Walk(projectDir, func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}
			if info.IsDir() {
				return nil
			}

			var header struct {
				Version string `json:"version"`
			}

			switch filepath.Ext(path) {
			case ".json", ".yaml", ".yml":
				if err := UnmarshalConfig(path, &header); err != nil {
					return nil // Not a gapi config file, just ignore.  continue walking
				} else if slices.Contains(versions, header.Version) {
					return OutputFile(rootConfig, rootConfigPath, path, output) // output file
				} else {
					return nil
				}
			default:
				return nil
			}
		})

		if walkErr != nil {
			return fmt.Errorf("error walking project directory: %w", walkErr)
		}
	}

	return nil
}

func OutputFile(rootConfig GApiRootConfig, rootConfigPath string, buildConfigPath string, output GApiRootOutputConfig) error {
	if buildConfig, err := LoadConfig(buildConfigPath); err != nil {
		return fmt.Errorf("failed to load config file: %w", err)
	} else {
		var builder IBuilder
		buildContext := BuildContext{
			output:          output,
			rootConfig:      rootConfig,
			buildConfig:     buildConfig,
			rootConfigPath:  rootConfigPath,
			buildConfigPath: buildConfigPath,
		}

		switch output.Language {
		case "golang":
			builder = &GolangBuilder{
				BuildContext: buildContext,
			}
		case "typescript":
			builder = &TypescriptBuilder{
				BuildContext: buildContext,
			}
		default:
			return fmt.Errorf("unsupported language: %s", output.Language)
		}

		switch output.Kind {
		case "server":
			return builder.BuildServer()
		case "client":
			return builder.BuildClient()
		default:
			return fmt.Errorf("unsupported kind: %s", output.Kind)
		}
	}
}
