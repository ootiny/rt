package builder

import (
	"embed"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"slices"
	"strings"

	"gopkg.in/yaml.v3"
)

// embed assets
//
//go:embed all:assets
var assets embed.FS

const MainLocation = "main"
const DBPrefix = "DB."
const APIPrefix = "API."

type IBuilder interface {
	Prepare() error
	BuildServer() error
	BuildClient() error
}

type BuildContext struct {
	location   string
	rtConfig   RTConfig
	apiConfigs []APIConfig
	output     RTOutputConfig
}

type RTOutputConfig struct {
	Kind       string `json:"kind" required:"true"`
	Language   string `json:"language" required:"true"`
	Dir        string `json:"dir" required:"true"`
	GoModule   string `json:"goModule"`
	GoPackage  string `json:"goPackage"`
	HttpEngine string `json:"httpEngine"`
}

type RTConfig struct {
	Listen       string           `json:"listen"`
	Outputs      []RTOutputConfig `json:"outputs"`
	__filepath__ string
}

func (c *RTConfig) GetFilePath() string {
	return c.__filepath__
}

type APIDefinitionAttributeConfig struct {
	Name        string `json:"name" required:"true"`
	Type        string `json:"type" required:"true"`
	Required    bool   `json:"required"`
	Description string `json:"description"`
}

type APIDefinitionConfig struct {
	Description string                         `json:"description"`
	Attributes  []APIDefinitionAttributeConfig `json:"attributes"`
}

type APIActionParameterConfig struct {
	Name        string `json:"name" required:"true"`
	Type        string `json:"type" required:"true"`
	Required    bool   `json:"required"`
	Description string `json:"description"`
}

type APIActionReturnConfig struct {
	Type        string `json:"type" required:"true"`
	Description string `json:"description"`
}

type APIActionConfig struct {
	Description string                     `json:"description"`
	Method      string                     `json:"method" required:"true"`
	Parameters  []APIActionParameterConfig `json:"parameters"`
	Return      APIActionReturnConfig      `json:"return"`
}

type APIConfig struct {
	Version      string                         `json:"version" required:"true"`
	Namespace    string                         `json:"namespace" required:"true"`
	Description  string                         `json:"description"`
	Definitions  map[string]APIDefinitionConfig `json:"definitions" required:"true"`
	Actions      map[string]APIActionConfig     `json:"actions"`
	__filepath__ string
}

func (c *APIConfig) GetFilePath() string {
	return c.__filepath__
}

func ParseProjectDir(filePath string, projectDir string) (string, error) {
	// Check for project directory placeholders in the filePath
	patterns := []string{
		"$projectdir",
		"$projectDir",
		"${ProjectDir}",
		"$ProjectDir",
		"$project",
		"$Project",
		"${projectDir}",
		"${projectdir}",
		"${Project}",
		"${project}",
	}

	result := filePath

	for _, pattern := range patterns {
		if strings.HasPrefix(filePath, pattern) {
			result = strings.Replace(result, pattern, projectDir, 1)
			break
		}
	}

	// If result is a relative path, convert it to an absolute path
	if !filepath.IsAbs(result) {
		if absPath, err := filepath.Abs(result); err != nil {
			return "", fmt.Errorf("failed to convert path to absolute path: %w", err)
		} else {
			result = absPath
		}
	}

	return result, nil
}

func UnmarshalConfig(filePath string, v any) error {
	if content, err := os.ReadFile(filePath); err != nil {
		return err
	} else {
		switch filepath.Ext(filePath) {
		case ".json":
			return json.Unmarshal(content, v)
		case ".yaml", ".yml":
			return yaml.Unmarshal(content, v)
		default:
			return fmt.Errorf("unsupported file extension: %s", filepath.Ext(filePath))
		}
	}
}

func WriteGeneratedFile(filePath string, content string) error {
	const BuilderStartTag = "tag-rt-api-builder-start"
	const BuilderEndTag = "tag-rt-api-builder-end"
	const BuilderDescription = "This file is generated by rt-builder, DO NOT EDIT."

	fileContent := fmt.Sprintf(
		"// %s: %s\n%s\n// %s",
		BuilderStartTag,
		BuilderDescription,
		content,
		BuilderEndTag,
	)

	return os.WriteFile(filePath, []byte(fileContent), 0644)
}

func NamespaceToFolder(location string, namespace string) string {
	//  change all namespace to lowercase
	namespace = strings.ToLower(namespace)

	// replace . with _
	namespace = strings.ReplaceAll(namespace, ".", "_")

	if location == MainLocation {
		return namespace
	} else {
		return fmt.Sprintf("%s_%s", location, namespace)
	}
}

func LoadRtConfig() (RTConfig, error) {
	configPath := ""

	if len(os.Args) > 1 {
		if fileInfo, err := os.Stat(os.Args[1]); err == nil && !fileInfo.IsDir() {
			configPath = os.Args[1]
		}
	}

	if configPath == "" {
		// 在当前目录下，依次寻找 .rt.json .rt.yaml .rt.yml
		searchFiles := []string{"./.rt.json", "./.rt.yaml", "./.rt.yml"}
		for _, file := range searchFiles {
			if fileInfo, err := os.Stat(file); err == nil && !fileInfo.IsDir() {
				configPath = file
				break
			}
		}
	}

	if !filepath.IsAbs(configPath) {
		if absPath, err := filepath.Abs(configPath); err != nil {
			return RTConfig{}, fmt.Errorf("failed to convert config path to absolute path: %v", err)
		} else {
			configPath = absPath
		}
	}

	var config RTConfig

	if err := UnmarshalConfig(configPath, &config); err != nil {
		return RTConfig{}, fmt.Errorf("failed to parse config file: %w", err)
	}

	projectDir := filepath.Dir(configPath)

	for i, output := range config.Outputs {
		var err error
		config.Outputs[i].Dir, err = ParseProjectDir(output.Dir, projectDir)
		if err != nil {
			return RTConfig{}, fmt.Errorf("failed to parse output dir: %w", err)
		}

		if !filepath.IsAbs(config.Outputs[i].Dir) {
			config.Outputs[i].Dir = filepath.Join(projectDir, config.Outputs[i].Dir)
		}

		if config.Outputs[i].GoModule != "" && config.Outputs[i].GoPackage == "" {
			goModuleArr := strings.Split(config.Outputs[i].GoModule, "/")
			config.Outputs[i].GoPackage = goModuleArr[len(goModuleArr)-1]
		}
	}

	config.__filepath__ = configPath

	return config, nil
}

func LoadAPIConfig(filePath string) (APIConfig, error) {
	var config APIConfig

	if err := UnmarshalConfig(filePath, &config); err != nil {
		return APIConfig{}, fmt.Errorf("failed to parse config file: %w", err)
	}

	config.__filepath__ = filePath

	return config, nil
}

func LoadAPIConfigFromDB(filePath string) (APIConfig, error) {
	fnDBTypeToAPIType := func(v string, klass string) string {
		switch v {
		case "PK":
			return "String"
		case "Bool":
			return "Bool"
		case "Int64":
			return "Int64"
		case "Float64":
			return "Float64"
		case "String", "String32", "String64", "String256":
			return "String"
		case "List<String>":
			return "List<String>"
		case "Map<String>":
			return "Map<String>"
		case "Bytes":
			return "Bytes"
		default:
			if strings.HasPrefix(v, "List<") && strings.HasSuffix(v, ">") {
				innerType := v[5 : len(v)-1]
				return fmt.Sprintf("List<%s@%s>", innerType, klass)
			} else if strings.HasPrefix(v, "Map<") && strings.HasSuffix(v, ">") {
				innerType := v[4 : len(v)-1]
				return fmt.Sprintf("Map<%s@%s>", innerType, klass)
			} else if strings.HasPrefix(v, DBPrefix) {
				return fmt.Sprintf("%s@%s", v, klass)
			} else {
				return v
			}
		}
	}

	var config struct {
		Table   string `json:"table"`
		Columns map[string]struct {
			Type     string `json:"type"`
			Required bool   `json:"required"`
		} `json:"columns"`
		Views map[string]struct {
			Columns []string `json:"columns"`
		} `json:"views"`
	}

	if err := UnmarshalConfig(filePath, &config); err != nil {
		return APIConfig{}, fmt.Errorf("failed to parse config file: %w", err)
	}

	definitions := map[string]APIDefinitionConfig{}

	for name, view := range config.Views {
		attributes := []APIDefinitionAttributeConfig{}

		for _, column := range view.Columns {
			columnName := ""
			columnType := ""
			columnArray := strings.Split(column, "@")
			if len(columnArray) == 1 {
				columnName = columnArray[0]
				columnType = fnDBTypeToAPIType(config.Columns[columnName].Type, "")
			} else {
				columnName = columnArray[0]
				columnType = fnDBTypeToAPIType(config.Columns[columnName].Type, columnArray[1])
			}

			attributes = append(attributes, APIDefinitionAttributeConfig{
				Name:     columnName,
				Type:     columnType,
				Required: config.Columns[columnName].Required,
			})
		}
		definitions[name] = APIDefinitionConfig{
			Attributes: attributes,
		}
	}

	return APIConfig{
		Version:     "rt.db.v1",
		Namespace:   config.Table,
		Definitions: definitions,
	}, nil
}

func Output() error {
	rtConfig, err := LoadRtConfig()
	if err != nil {
		log.Panicf("Failed to load config: %v", err)
	}

	apiVersions := []string{"rt.api.v1"}
	dbVersions := []string{"rt.db.v1"}
	projectDir := filepath.Dir(rtConfig.GetFilePath())
	log.Printf("rt: project dir: %s\n", projectDir)
	log.Printf("rt: config file: %s\n", rtConfig.GetFilePath())

	apiConfigs := []APIConfig{}

	for _, output := range rtConfig.Outputs {
		walkErr := filepath.Walk(projectDir, func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}
			if info.IsDir() {
				return nil
			}

			var header struct {
				Version string `json:"version"`
			}

			switch filepath.Ext(path) {
			case ".json", ".yaml", ".yml":
				if err := UnmarshalConfig(path, &header); err != nil {
					return nil // Not a rt config file, just ignore.  continue walking
				} else if slices.Contains(apiVersions, header.Version) {
					if apiConfig, err := LoadAPIConfig(path); err != nil {
						return err
					} else {
						apiConfigs = append(apiConfigs, apiConfig)
						return nil
					}
				} else if slices.Contains(dbVersions, header.Version) {
					if apiConfig, err := LoadAPIConfigFromDB(path); err != nil {
						return err
					} else {
						apiConfigs = append(apiConfigs, apiConfig)
						return nil
					}
				} else {
					return nil
				}
			default:
				return nil
			}
		})

		if walkErr != nil {
			return fmt.Errorf("error walking project directory: %w", walkErr)
		}

		var builder IBuilder

		context := BuildContext{
			location:   MainLocation,
			rtConfig:   rtConfig,
			apiConfigs: apiConfigs,
			output:     output,
		}

		switch output.Language {
		case "go":
			builder = &GoBuilder{
				BuildContext: context,
			}
		case "typescript":
			builder = &TypescriptBuilder{
				BuildContext: context,
			}
		default:
			return fmt.Errorf("unsupported language: %s", context.output.Language)
		}

		if err := builder.Prepare(); err != nil {
			return err
		}

		switch context.output.Kind {
		case "server":
			if err := builder.BuildServer(); err != nil {
				return err
			}
		case "client":
			if err := builder.BuildClient(); err != nil {
				return err
			}
		default:
			return fmt.Errorf("unsupported kind: %s", context.output.Kind)
		}
	}

	return nil
}
